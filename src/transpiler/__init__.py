"""
Transpiler module for converting our language AST to valid Python code.
This transpiler takes the AST generated by our parser and converts it to
executable Python code.
"""

class Transpiler:
    def __init__(self):
        self.indentation = 0
        self.indent_str = "    "  # 4 spaces for Python indentation
    
    def transpile(self, ast):
        """
        Convert AST to Python code.
        
        Args:
            ast: Abstract Syntax Tree generated by the parser
            
        Returns:
            str: Valid Python code
        """
        python_code = []
        for node in ast:
            python_code.append(self._transpile_node(node))
        
        return "\n".join(python_code)
    
    def _indent(self):
        return self.indent_str * self.indentation
    
    def _transpile_node(self, node):
        """Convert a single AST node to Python code."""
        if node['type'] == 'Assignment':
            return f"{self._indent()}{node['identifier']} = {self._transpile_node(node['value'])}"
        
        elif node['type'] == 'BinaryOperation':
            left = self._transpile_node(node['left'])
            right = self._transpile_node(node['right'])
            return f"({left} {node['operator']} {right})"
        
        elif node['type'] == 'Comparison':
            left = self._transpile_node(node['left'])
            right = self._transpile_node(node['right'])
            # Python uses the same comparison operators as our language
            return f"({left} {node['operator']} {right})"
        
        elif node['type'] == 'IfStatement':
            condition = self._transpile_node(node['condition'])
            
            # Process the true branch
            self.indentation += 1
            if_body = self._transpile_node(node['true_branch'])
            self.indentation -= 1
            
            result = f"{self._indent()}if {condition}:\n{if_body}"
            
            # Add else branch if it exists
            if node['false_branch']:
                self.indentation += 1
                else_body = self._transpile_node(node['false_branch'])
                self.indentation -= 1
                result += f"\n{self._indent()}else:\n{else_body}"
                
            return result
        
        elif node['type'] == 'WhileStatement':
            condition = self._transpile_node(node['condition'])
            
            self.indentation += 1
            body = self._transpile_node(node['body'])
            self.indentation -= 1
            
            return f"{self._indent()}while {condition}:\n{body}"
        
        elif node['type'] == 'Block':
            result = []
            for statement in node['statements']:
                result.append(self._transpile_node(statement))
            return "\n".join(result)
        
        elif node['type'] == 'FunctionDefinition':
            params = ", ".join(node['parameters'])
            
            # Save the current indentation level
            current_indent = self.indentation
            
            # Increase indentation for function body
            self.indentation += 1
            body = self._transpile_node(node['body'])
            # Restore indentation level
            self.indentation = current_indent
            
            return f"{self._indent()}def {node['name']}({params}):\n{body}"
        
        elif node['type'] == 'ReturnStatement':
            return f"{self._indent()}return {self._transpile_node(node['value'])}"
        
        elif node['type'] == 'FunctionCall':
            args = []
            for arg in node['arguments']:
                args.append(self._transpile_node(arg))
            arg_str = ", ".join(args)
            
            return f"{node['name']}({arg_str})"
        
        elif node['type'] == 'Number':
            return node['value']
        
        elif node['type'] == 'Identifier':
            return node['value']
        
        elif node['type'] == 'LogicalOperation':
            left = self._transpile_node(node['left'])
            right = self._transpile_node(node['right'])
            return f"({left} {node['operator']} {right})"
        
        else:
            raise Exception(f"Unknown node type: {node['type']}")